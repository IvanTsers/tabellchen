#+begin_export latex
The package \texttt{tabellchen} has hooks for imports, data types,
methods and functions.
#+end_export
#+begin_src go <<tabellchen.go>>=
  package tabellchen
  import (
	  //<<Imports>>
  )
  //<<Types and methods>>
  //<<Functions>>
#+end_src
#+begin_export latex
\subsection{Type \texttt{ReadConfig}}
The data type \texttt{ReadConfig} contains parameters for the function
\texttt{ReadTable}, which we will define in this package.
#+end_export
#+begin_src go <<Types and methods>>=
  type ReadConfig struct {
	  FilePath    string
	  Separator   rune
	  CommentChar rune
	  HasHeader   bool
  }
#+end_src
#+begin_export latex
\subsection{Type \texttt{WriteConfig}}
The data type \texttt{ReadConfig} contains parameters for the function
\texttt{WriteTable}, which we will define in this package.
#+end_export
#+begin_src go <<Types and methods>>=
  type WriteConfig struct {
	  File        *os.File
	  Separator   rune
  }
#+end_src
#+begin_export latex
We import \texttt{os}.
#+end_export
#+begin_src go <<Imports>>=
  "os"
#+end_src
#+begin_export latex
\subsection{Type \texttt{Table}}
We define a struct-based data structure for tables. A table contains
coulmn headers and rows of data. Both headers and data shall contain
entries of \texttt{string} type.
#+end_export
#+begin_src go <<Types and methods>>=
  type Table struct {
	  Header []string
	  Rows [][]string
  }
#+end_src
#+begin_export latex
\subsubsection{Constructor method \texttt{NewTable}}
!The method \texttt{NewTable} creates a table with specified header
!and rows.
#+end_export
#+begin_src go <<Types and methods>>=
  func NewTable(header []string, rows [][]string) Table {
	  t := Table{
		  Header: header,
		  Rows: rows,
	  }
	  return t
  }
#+end_src
#+begin_export latex
\subsubsection{Function \texttt{ReadTable}}
!The function \texttt{ReadTable} reads data from a file and populates
!a \texttt{Table}. It accepts a \texttt{ReadConfig} struct.

We 'unpack' the \texttt{config} fields. Then we begin with opening a
file. Then we create a \texttt{Table} to populate, initialize
variables for the number of fields and current line, initialize a
scanner, and mark that we are going to read the first line of the
file. Then we iterate over lines of the file and check whether the
scanner has returned an error while reading the file. Should
everything go well, we return the populated \texttt{Table} and a
\texttt{nil} error.
#+end_export
#+begin_src go <<Functions>>=
  func ReadTable(config ReadConfig) (Table, error) {
	  path := config.FilePath
	  separator := config.Separator
	  commentChar := config.CommentChar
	  hasHeader := config.HasHeader

	  file, err := os.Open(path)
	  if err != nil {
		  return Table{},
		  fmt.Errorf("Failed to open file: %v\n", err)
	  }
	  defer file.Close()
	  table := Table{}
	  numFields := 0
	  currentLine := 0
	  scanner := bufio.NewScanner(file)
	  firstLine := true

	  for scanner.Scan() {
		  //<<Scan lines and populate the table>>
	  }

	  if err := scanner.Err(); err != nil {
		  return Table{},
		  fmt.Errorf("Error reading file: %v\n", err)
	  }

	  return table, nil
  }
#+end_src
#+begin_export latex
We import \texttt{fmt} and \texttt{bufio}.
#+end_export
#+begin_src go <<Imports>>=
  "fmt"
  "bufio"
#+end_src
#+begin_export latex
As the scanner advances, we read a line of the file. If the line is
empty or starts with the comment character, we skip it. We split all
other lines into fields, handle the header, check if a current row has
the proper length and append it to the \texttt{Table}.
#+end_export
#+begin_src go <<Scan lines and populate the table>>=
  line := scanner.Text()
  currentLine += 1
  if len(line) == 0 {
	  continue
  }
  if rune(line[0]) == commentChar {
	  continue
  }
  //<<Split lines into fields>>
  //<<Handle the first line>>
  //<<Validate row length>>
  //<<Append the row to the table>>
#+end_src
#+begin_export latex
The line is getting split into a slice of strings based on a custom
separator. For this, we use an anonymous function to compare each
character of the line to the comment character.
#+end_export
#+begin_src go <<Split lines into fields>>=
  fields := strings.FieldsFunc(line, func(c rune) bool {
	  return c == separator
  })
#+end_src
#+begin_export latex
We import \texttt{strings}.
#+end_export
#+begin_src go <<Imports>>=
  "strings"
#+end_src
#+begin_export latex
We consider that the first line defines the number of columns in the
table. We remember the number of fields in the first line. Then we
handle it as \texttt{Table}'s header if the corresponding option had
been toggled. If it was hadn't been toggled, we fill the header with
an empty slice of strings and append the first line to the table.
#+end_export
#+begin_src go <<Handle the first line>>=
  if firstLine {
	  numFields = len(fields)
	  if hasHeader {
		  table.Header = fields
	  } else {
		  table.Header = []string{}
		  table.Rows = append(table.Rows, fields)

	  }
	  firstLine = false
	  continue
  }
#+end_src
#+begin_export latex
If the number of fields in the line does not correspond to the number
of fields of the first line, we stop and return an empty table and an
error message.
#+end_export
#+begin_src go <<Validate row length>>=
  if len(fields) != numFields {
	  return Table{},
	  fmt.Errorf("Line %d has %d fields, expected %d\n",
		  currentLine,
		  len(fields),
		  numFields)
  }
#+end_src
#+begin_export latex
Finally, we append a new row to the \texttt{Table}.
#+end_export
#+begin_src go <<Append the row to the table>>=
  table.Rows = append(table.Rows, fields)
#+end_src
#+begin_export latex
\subsubsection{Method \texttt{ColIdByName}}
To find a column index by its name, we iterate over the table's
header and compare its fields to the desired column name.
#+end_export
#+begin_src go <<Types and methods>>=
  func (t *Table) ColIdByName(colname string) (int, error) {
	  id := -1
	  for i, h := range t.Header {
		  if h == colname {
			  id = i
			  break
		  }
	  }
	  var err error = nil
	  if id == -1 {
		  err = fmt.Errorf("ColIdByName: " +
			  "column '%s' not found\n", colname)
	  }
	  return id, err
  }
#+end_src
#+begin_export latex
\subsection{Method \texttt{Filter}}
!The method \texttt{Filter} returns rows of a \texttt{Table} that
!satisfy a condition.

We check if the specified column is within table's bounds. If not so,
we return early. After the check, we iterate over the input rows and
append eligible rows to a new table. We replace the original table
with the filtered one at the end.
#+end_export
#+begin_src go <<Functions>>=
  func (t *Table) Filter (colId int, cond func(string) bool) error {
	  var err error
	  err = t.checkColBounds(colId)
	  if err != nil {
		  return err
	  }
	
	  filteredRows := [][]string{}
	  for _, row := range t.Rows {
		  if cond(row[colId]) {
			  filteredRows = append(filteredRows, row)
		  }
	  }
	  t.Rows = filteredRows
	  return err
  }
#+end_src
#+begin_export latex
\subsection{Helper method \texttt{checkColBounds}}
This helper method checks if the specified column index is within the
bounds of the table. It returns a non-\texttt{nil} error if the index
is out of bounds.

We count the number of columns and compare the specified column
identifier to zero and the number of columns the table contains. If
the specified column is out of bounds, we create an error message and
return early.
#+end_export
#+begin_src go <<Types and methods>>=
  func (t *Table) checkColBounds (colId int) error {
	  var err error
	  ncol := len(t.Rows[0])
	  if colId < 0 || colId >= ncol {
		  err = fmt.Errorf("column %d is out of bounds",
			  colId)
	  }
	  return err
  }
#+end_src
#+begin_export latex
\subsection{Method \texttt{GetCol}}
!The method \texttt{GetCol} retrieves the specified column from a
!table.

We initialize the return variables, then we check if the specified
column is within table's bounds. After that, we count the table's rows
and append each row element of the specified column to the return
variable \texttt{col}. We return the result once we are finished.
#+end_export
#+begin_src go <<Types and methods>>=
  func (t *Table) GetCol(colId int) ([]string, error) {
	  var err error = nil
	  var col []string
	  //Is column within bounds?
	  nrow := len(t.Rows)
	  for i := 0; i < nrow; i++ {
		  col = append(col, t.Rows[i][colId])
	  }
	  return col, err
  }
#+end_src
#+begin_export latex
We count the number of columns and compare the specified column
identifier to zero and the number of columns the table contains. If
the specified column is out of bounds, we create an error message and
return early.
#+end_export
#+begin_src go <<Is column within bounds?>>=
  ncol := len(t.Header)
  if colId < 0 || colId > ncol {
	  err = fmt.Errorf("GetCol: column %d is " +
		  "out of bounds\n", colId)
	  return col, err
  }
#+end_src
#+begin_export latex
\subsection{Function \texttt{GreaterOrEqual}}
!The function \texttt{GreaterOrEqual} returns a \texttt{cond}
!filtering function that checks if a string converted to a float is
!greater or equal to a value.

In the produced function, we convert the input string value to a float
and compare it to the threshold. If the conversion failed, we print an
error.
#+end_export
#+begin_src go <<Functions>>=
  func GreaterOrEqual(threshold float64) func(string) bool {
	  return func(s string) bool {
	      v, err := strconv.ParseFloat(s, 64)
		  if err != nil {
			  fmt.Errorf("GreaterOrEqual: failed " +
				  "to parse the string %s: " +
				  "%v\n", s, err) 
		  return false
	  }
	      return v >= threshold
      }
  }
#+end_src
#+begin_export latex
\subsection{Method \texttt{ColUnique}}
!The method \texttt{ColUnique} returns unique values found in a
!column.

We begin with extracting the target column from the table. We report
the error if any and exit. If there are no errors, we measure column's
length, initialize a variable to store unique values, search for them,
and return the result.
#+end_export
#+begin_src go <<Types and methods>>=
  func (t *Table) ColUnique(colId int) []string {
	  col, err := t.GetCol(colId)
	  if err != nil {
		  log.Fatal(err)
	  }
	  colLen := len(col)	
	  var res []string
	  res = append(res, col[0])

	  //<<Find unique values>>

	  return res
  }
#+end_src
#+begin_export latex
We import \texttt{log}.
#+end_export
#+begin_src go <<Imports>>=
  "log"
#+end_src
#+begin_export latex
We iterate over the column slice and compare the current value to
values we have already found and added to \texttt{res}. If there is a
new value, we add it to \texttt{res}.
#+end_export
#+begin_src go <<Find unique values>>=
  for i := 0; i < colLen; i++ {
	  found := false
	  for j := 0; j < len(res); j++ {
		  if col[i] == res[j] {
			  found = true
			  break
		  }
	  }
	  if !found {
		  res = append(res, col[i])
	  }
  }
#+end_src
#+begin_export latex
We import \texttt{strconv}.
#+end_export
#+begin_src go <<Imports>>=
  "strconv"
#+end_src
#+begin_export latex
\subsection{Method \texttt{WriteTable}}
!The method \texttt{WriteTable} writes a \texttt{Table} into an
!os.File.

We 'unpack' the \texttt{config}, initialize an error, create a writer
for the file, write the header and the rows.
#+end_export
#+begin_src go <<Types and methods>>=
  func (t *Table) WriteTable(config WriteConfig) error {
	  file := config.File
	  separator := config.Separator
	
	  var writeErr error
	  writer := bufio.NewWriter(file)
	  defer writer.Flush()
	  //<<Write the header>>
	  //<<Write the rows>>
	  return writeErr
  }
#+end_src
#+begin_export latex
We concatenate the \texttt{Header} fields using the
\texttt{separator}. Then we write the result appending a newline at
the end. If the writer has returned an error, we print it.
#+end_export
#+begin_src go <<Write the header>>=
  if len(t.Header) > 0 {
	  stringHeader := strings.Join(t.Header, string(separator))
	  _, err := writer.WriteString(stringHeader + "\n")
	  if err != nil {
		  writeErr := fmt.Errorf("WriteTable: failed " +
			  "to write header: %v\n", err) 
		  return writeErr
	  }
  }
#+end_src
#+begin_export latex
We initialize a row counter for writing the rows, concatenate the
\texttt{Rows} fields using the \texttt{separator}. Then we write the
result appending a newline at the end. If the writer has returned an
error, we print the error and the number of the troublesome row.
#+end_export
#+begin_src go <<Write the rows>>=
  rn := 0
  for _, row := range t.Rows {
	  stringRow := strings.Join(row, string(separator))
	  _, err := writer.WriteString(stringRow + "\n")
	  if err != nil {
		  writeErr := fmt.Errorf("WriteTable: failed " +
			  "to write row %d: %v\n", rn, err) 
		  return writeErr
	  }
	  rn += 1
  }
#+end_src
#+begin_export latex
\subsection{Method \texttt{NewColumn}}
!The method \texttt{NewColumn} creates a new empty named column in a
!\texttt{Table}.

We append a new header to the slice of headers and initialize a slice
of empty rows for it.
#+end_export
#+begin_src go <<Types and methods>>=
  func (t *Table) NewColumn(colName string) {
	  t.Header = append(t.Header, colName)

	  for i := range t.Rows {
		  t.Rows[i] = append(t.Rows[i], "")
	  }
  }
#+end_src
#+begin_export latex
\subsection{Method \texttt{ReorderColumns}}
!The method \texttt{ReorderColumns} changes the order of table's
!columns according to the order of specified indices.

We validate the new indices, then change the order of headers and
coulmns in-place. The only return of the method is an error.
#+end_export
#+begin_src go <<Types and methods>>=
  func (t *Table) ReorderColumns(newOrder ...int) error {
	  //<<Validate the new order>>
	  //<<Reorder the header>>
	  //<<Reorder the rows>>
	  return nil
  }
#+end_src
#+begin_export latex
The number of indices in the \texttt{newOrder} has to be equal to the
number of columns, the indices have to be within bounds of the
table and contain unique integers.
#+end_export
#+begin_src go <<Validate the new order>>=
  numCols := len(t.Header)
  if len(newOrder) != numCols {
	  return fmt.Errorf("ReorderColumns: " +
		  "expected %d indices, got %d",
		  numCols, len(newOrder))
  }
  //<<Are the new indices within bounds and unique?>>
#+end_src
#+begin_export latex
We initialize a map of seen indices and iterate over the
\texttt{newOrder} to check if its indices are within bounds of the
table and are not seen more than once.
#+end_export
#+begin_src go <<Are the new indices within bounds and unique?>>=
  seen := make(map[int]bool)
  for _, index := range newOrder {
	  if index < 0 || index >= numCols {
		  return fmt.Errorf("ReorderColumns: " +
			  "Index out of range: %d", index)
	  }
	  if seen[index] {
		  return fmt.Errorf("ReorderColumns: " +
			  "Duplicate index: %d", index)
	  }
	  seen[index] = true
  }
#+end_src
#+begin_export latex
We reorder the header using the new indices.
#+end_export
#+begin_src go <<Reorder the header>>=
  newHeader := make([]string, numCols)
  for i, newIndex := range newOrder {
	  newHeader[i] = t.Header[newIndex]
  }
  t.Header = newHeader
#+end_src
#+begin_export latex
Likewise, we reorder the rows.
#+end_export
#+begin_src go <<Reorder the rows>>=
  for i := range t.Rows {
	  newRow := make([]string, numCols)
	  for j, newIndex := range newOrder {
		  newRow[j] = t.Rows[i][newIndex]
	  }
	  t.Rows[i] = newRow
  }
#+end_src
